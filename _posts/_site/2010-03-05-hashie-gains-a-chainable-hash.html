<p><a href="http://intridea.com/2009/11/12/hashie-the-hash-toolkit">Hashie</a>, Intridea&#8217;s Hash Toolkit, is today with version 0.2.0 gaining a new member: the Clash.</p>
<p>A Clash is a &#8220;Chainable Lazy Hash&#8221; that allows you to construct a hash using method syntax. It is meant to be used in a similar way to the way that Rails 2.x&#8217;s <code>named_scope</code> or Arel&#8217;s query building work. Let&#8217;s start with an example:</p>
<div>
<pre>
<code class='ruby'>require 'hashie/clash'
<p>c = Hashie::Clash.new<br />
c.where(:abc =&gt; &#8216;def&#8217;).order(:created_at)</p>
<p>c == {:where =&gt; {:abc =&gt; &#8217;def&#8217;}, :order =&gt; :created_at}</code><br />
  </pre></p>
</div>
<p>Pretty neat, right? But you can go beyond that. Clash also allows you to use bang method notation to create, dive into, and return from sub-hashes. Let me show you what I mean:</p>
<div>
<pre>
<code class='ruby'>c = Hashie::Clash.new
<p>c.where<img src=".abc(&#39;def&#39;).ghi(123)._end" alt="" />.order(:created_at)</p>
<p>c == {:where =&gt; {:abc =&gt; &#8216;def&#8217;, :ghi =&gt; 123}, :order =&gt; :created_at}</code><br />
  </pre></p>
</div>
<p>By using a bang method, you automatically create a subhash that is then the subject of the chain, allowing you to create more keys on that subhash. Then, if you want to jump back up to the top-level hash, you simply call the <code>_end!</code> method to return up one level in the stack (thanks to jQuery for that particular inspiration).</p>
<p>While Clash is a very simple tool, we hope that it could eventually make its way into some of the new ORMs that are cropping up around NoSQL systems (such as <a href="http://github.com/jnunemaker/mongomapper">MongoMapper</a>) to provide the same kind of effortless chaining that has made ActiveRecord so easy to work with.</p>