<p>Twitter&#8217;s <a href="http://apiwiki.twitter.com/Streaming-API-Documentation">Streaming <span class="caps">API</span></a> is one of the most exciting developments in the Twitter <span class="caps">API</span> in some time. It gives you the ability to create a long-standing connection to Twitter that receives &#8220;push&#8221; updates when new tweets matching certain criteria arrive, obviating the need to constantly poll for updates. <a href="http://github.com/intridea/tweetstream">TweetStream</a> is a Ruby library to access the new <span class="caps">API</span>.</p>
<h3>Installation</h3>
<p>Installation of TweetStream is simple, it&#8217;s available as a gem on GitHub and <a href="http://gemcutter.org/">Gemcutter.org</a>. To install it from GitHub:</p>
<div>
<pre>
<code class='bash'>gem sources -a http://gems.github.com
<p>gem install intridea-tweetstream</code><br />
  </pre></p>
</div>
<p>To install it from Gemcutter:</p>
<div>
<pre>
<code class='bash'>gem sources -a http://gemcutter.org
<p>gem install tweetstream</code><br />
  </pre></p>
</div>
<h3>Usage</h3>
<p>TweetStream creates a long-standing <span class="caps">HTTP</span> connection to Twitter, so unlike other Twitter libraries you don&#8217;t simply run it once and deal with the results. Instead, you provide a block that will be yielded to with each new status that arrives. The most basic example is:</p>
<div>
<pre>
<code class='ruby'>require 'rubygems'
<p>require &#8216;tweetstream&#8217;</p>
<p>TweetStream::Client.new(&#8216;user&#8217;,&#8216;pass&#8217;).sample do |status|<br />
  puts &quot;[#{status.user.screen_name}] #{status.text}&quot;<br />
end</code><br />
  </pre></p>
</div>
<p>This will provide you with a small sample snapshot of all of the updates being posted to Twitter at this moment and print them to the screen. There are also methods available to track single-word keywords as well as the updates of a specified list of user ids (integers, not screen names). You can do that like so:</p>
<div>
<pre>
<code class='ruby'># Track the terms 'keyword1' and 'keyword2'
<p>TweetStream::Client.new(&#8216;user&#8217;,&#8216;pass&#8217;).track(&#8216;keyword1&#8217;, &#8216;keyword2&#8217;) do |status|<br />
  puts &quot;[#{status.user.screen_name}] #{status.text}&quot;<br />
end</p>
<ol>
	<li>Track users with IDs 123 and 456<br />
TweetStream::Client.new(&#8216;user&#8217;,&#8216;pass&#8217;).follow(123, 456) do |status|<br />
  puts &quot;[#{status.user.screen_name}] #{status.text}&quot;<br />
end</code><br />
  </pre><br />
</div></li>
</ol>
<h3>Daemonization</h3>
<p>One of the most useful features of TweetStream is its built-in daemonization functionality. This allows you to create scripts that run in the background of your machine rather than taking up an active process. To create a daemon script, you simply use <code>TweetStream::Daemon</code> instead of <code>TweetStream::Client</code>. Here&#8217;s an example:</p>
<div>
<pre>
<code class='ruby'>require 'rubygems'
<p>require &#8216;tweetstream&#8217;</p>
<ol>
	<li>The third argument is an optional process name.<br />
TweetStream::Daemon.new(&#8216;user&#8217;,&#8216;pass&#8217;,&#8216;tracker&#8217;).track(&#8216;keyword1&#8217;,&#8216;keyword2&#8217;) do |status|</li>
	<li>Do something like dump the status to ActiveRecord</li>
	<li>or anything else you want.<br />
end</code><br />
  </pre><br />
</div></li>
</ol>
<p>If you were to place the above code in a file called <code>tracker.rb</code> you could then run <code>ruby tracker.rb</code> to see a list of daemonization commands such as start, stop, or run.</p>
<p>TweetStream is a simple wrapper on the Streaming <span class="caps">API</span>, but with built-in daemonization provides powerfully flexible means of accessing the Twitter Streaming <span class="caps">API</span> using familiar Ruby tools. More complete code documentation is <a href="http://rdoc.info/projects/intridea/tweetstream">available at rdoc.info</a>.</p>