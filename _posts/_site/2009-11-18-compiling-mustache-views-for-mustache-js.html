<p>I&#8217;ve been investigating the usage of <a href="http://github.com/defunkt/mustache">Mustache</a>, the dead-simple templating language with the funny name, and one very enticing aspect of Mustache is that it&#8217;s so simple it can easily be ported across languages. <a href="http://github.com/janl/mustache.js">Mustache.js</a> is a Javascript implementation of Mustache that works based on a simple <span class="caps">JSON</span> hash and a string template. Wouldn&#8217;t it be awesome if we could use the same Mustache template on the server side and in Javscript without having to construct two sets of logic? Yes it would, and here&#8217;s how.</p>
<h3>Creating a Serializable Mustache</h3>
<p>Mustache works by calling methods from the template on the Mustache view object. There are no arguments, no filters, just plain old Ruby methods. Mustache.js works by reading values from a Javascript object or evaluating functions on<br />
that object. So, if we want to use the same logic to power both our Ruby-built Mustaches and our Javascript-built Mustaches, all we need to do is convert that logic to <span class="caps">JSON</span>!</p>
<p>Now, you could write a <code>#to_json</code> method for each of your Mustache views, but where&#8217;s the DRYness in that? Instead let&#8217;s create a Serializable Mustache that automatically catalogs the methods that need to be serialized to <span class="caps">JSON</span>:</p>
<div>
<pre>
<code class='ruby'>module Mustache::Serializable
def self.included(base)
base.extend ClassMethods
end

module ClassMethods
def serializable_methods
public_instance_methods(false)
end
end
def serializable_hash
hash = self.class.serializable_methods.inject({}) do |result, method|
<ol>
	<li>Symbolize the method to work better with the Mustache Context.<br />
      result[method.to_sym] = self.send(method)<br />
      result<br />
    end</li>
</ol>
hash.merge!(self.context)
end
def to_json
serializable_hash.to_json
end
<p>end</code><br />
  </pre></p>
</div>
<p>That was easy enough! What we&#8217;re doing is compiling a list of methods that we want to serialize by saying &#8216;any public method that is declared in <strong>this specific Mustache class</strong> should be serialized&#8217;, constructing a hash from those methods, merging in the Mustache&#8217;s context, and providing a <span class="caps">JSON</span> representation of that hash.</p>
<h3>Rendering in Ruby</h3>
<p>Now that you have a simple way to serialize to <span class="caps">JSON</span>, we need to actually be able to render this Mustache in it&#8217;s server-side native form: Ruby. Here let&#8217;s say we&#8217;re working on a Sinatra application since it has probably the simplest setup. We&#8217;re not going to use the built-in Sinatra support from Mustache because it will be clearer in the code if we don&#8217;t. Here&#8217;s the entire application (make sure you somehow include the serializable code from above):</p>
<div>
<pre>
<code class='ruby'>require 'rubygems'
<p>require &#8216;sinatra&#8217;<br />
require &#8216;mustache&#8217;</p>
<p>class Person &lt; Mustache<br />
  include Mustache::Serializable</p>
def initialize(first_name, last_name)
@first_name = first_name
@last_name = last_name
end

def formal_name
&quot;#{@last_name}, #{@first_name}&quot;
end

def initials
&quot;#{@first_name[0..0]}.#{@last_name[0..0]}&quot;
end

template = &lt;&lt;-<span class="caps">HTML</span>
&lt;dl&gt;
&lt;dt&gt;Formal Name:&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;
&lt;dt&gt;Initials:&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;
<span class="caps">HTML</span>
<p>end</p>
<p>get &#8216;/person/:last_name/:first_name.:format&#8217; do<br />
  @mustache = Person.new(params[:first_name], params[:last_name])<br />
  @mustache.to_html<br />
end</code><br />
  </pre></p>
</div>
<h3>Rendering in Javascript</h3>