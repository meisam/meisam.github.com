<p>There is a piece of code that shows up more than 80% of the controllers that I write, and it goes a little something like this:</p>
<pre name="code" class="ruby">class UsersController &lt; ApplicationController
  def user
    @user ||= User.find(params[:id])
  end
  helper_method :user
end</pre>
<p>A simple memoization method to allow me to easily grab the parameter-referred user in all of my actions. If I&#8217;m using nested routes, that means I can write two, maybe three of these methods into a controller. I&#8217;m basically using slight variations on the same code 20 different times in an application. Since we live in a world that loves to be <span class="caps">DRY</span>, I thought, &#8220;I can do better.&#8221;</p>
<h3>Fetches: Memoizing Your Parameter Record Retrieval</h3>
<p>Fetches is a simple extension to ActionController that lets you simply define those kinds of fetch methods on a one-line command. For the example above, I can rewrite it like so:</p>
<pre name="code" class="ruby">class UsersController &lt; ApplicationController
  fetches :user
end</pre>
<p>That&#8217;s pretty useful! Not only can I call the &#8220;<code>user</code>&#8221; method from the controller, but it&#8217;s automatically helperized so that I can use the same call in my views. Of course, there are times when more advanced fetching is called for, say using a method other than <code>find</code> or storing to a different variable name. Let&#8217;s take a look at a slightly more complex example:</p>
<pre name="code" class="ruby"># assuming a route like /users/:user_id/articles/:id
class ArticlesController &lt; ApplicationController
  fetches :user, :as =&gt; :author, :from =&gt; :user_id, :using =&gt; :find_by_login
  fetches :article
end</pre>
<p>Now if I were to call &#8220;<code>author</code>&#8221; in any of my controller actions, it would be equivalent to <code>User.find_by_login(params[:user_id])</code>. Similarly, calling &#8220;<code>article</code>&#8221; is equivalent to <code>Article.find(params[:id])</code>. The &#8220;from&#8221; option can also take a Proc in case your fetching is not simply a parameter key:</p>
<pre name="code" class="ruby">class UsersController &lt; ApplicationController
  fetches :user, :from =&gt; Proc.new{ |c| c.params[:user_id] || c.params[:id] }
end</pre>
<p>The main advantages to <strong>fetches</strong> are brevity, clarity and DRYness. I&#8217;ve found that this method covers every use case for parameter-based fetching that I&#8217;ve needed, and as such provides a much simpler, more readable, and shorter way to fetch models for use in your controller and views.</p>
<h3>Installation</h3>
<p>Fetches is available as a gem as well as in traditional plugin format. To install<br />
as a gem, add this to your environment.rb:</p>
<pre name="code" class="ruby">config.gem 'mbleigh-fetches', :source =&gt; 'http://gems.github.com', :lib =&gt; "fetches"</pre>

<p>To install it as a traditional plugin:</p>
<pre><code>script/plugin install git://github.com/mbleigh/fetches.git</pre>
<h3>Resources</h3>
<p>The source is <a href="http://github.com/mbleigh/fetches">available on GitHub</a>, the <a href="http://actsascommunity.com/projects/fetches">Acts As Community project</a> is there for general discussion, and <a href="http://mbleigh.lighthouseapp.com/projects/14793-fetches/overview">the Lighthouse</a> is there for bugs and feature suggestions.</p>
<p><strong><span class="caps">UPDATE</span>:</strong> A commenter requested that the plugin be able to handle creation of new records in addition to fetching existing records. I have added in the <code>:initialize</code> option to do just this. Examples:</p>
<pre name="code" class="ruby">fetches :user, :initialize =&gt; true # initialize from params[:user]
fetches :user, :initialize =&gt; :author # initialize from params[:author]
fetches :user, :initialize =&gt; Proc.new{ |c| {:login =&gt; c.params[:login], :email =&gt; c.params[:email]} }</pre>